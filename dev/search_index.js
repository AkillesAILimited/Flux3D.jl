var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"CurrentModule = Flux3D","category":"page"},{"location":"#Flux3D-1","page":"Home","title":"Flux3D","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [Flux3D]","category":"page"},{"location":"#Flux3D.NormalizePointCloud","page":"Home","title":"Flux3D.NormalizePointCloud","text":"NormalizePointCloud(; inplace::Bool=true)\n\nNormalize PointCloud with mean at origin and unit standard deviation.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of PointCloud.\n\nSee also: normalize, normalize!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.NormalizeTriMesh","page":"Home","title":"Flux3D.NormalizeTriMesh","text":"NormalizeTriMesh(; inplace::Bool=true)\n\nNormalize TriMesh with mean at origin and unit standard deviation.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: normalize, normalize!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.OffsetTriMesh","page":"Home","title":"Flux3D.OffsetTriMesh","text":"OffsetTriMesh(offset_verts::AbstractArray{<:Number,2}; inplace::Bool=true)\n\nAdd offset to the TriMesh by given offset vertices offset_verts\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: offset, offset!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.PointCloud","page":"Home","title":"Flux3D.PointCloud","text":"PointCloud\n\nInitialize PointCloud representation.\n\npoints should be Array of size (D, N, B) where N is the number of points, D is dimensionality of each points (i.e. D=2 or D=3) and B is the batch size of PointCloud. normals is optional field, if given should be Array of size (D, N, B) where N and B should match with the N and B of points and D=2 or D=3 (i.e. normals for 2D and 3D PointCloud respectively).\n\nFields:\n\npoints      - Points that makes up whole PointCloud.\nnormals     - Normals of each points in PointCloud.\n\nAvailable Contructor:\n\nPointCloud(points, normals=nothing)\nPointCloud(;points, normals=nothing)\nPointCloud(pcloud::PointCloud)\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.ReAlignPointCloud","page":"Home","title":"Flux3D.ReAlignPointCloud","text":"ReAlignPointCloud(target::PointCloud; inplace::Bool=true)\nReAlignPointCloud(target::AbstractArray{<:Number, 2}; inplace::Bool=true)\n\nRe-Align PointCloud to axis aligned bounding box of target PointCloud.\n\ninput PointCloud and target PointCloud should be of same size. inplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of PointCloud.\n\nSee also: realign, realign!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.ReAlignTriMesh","page":"Home","title":"Flux3D.ReAlignTriMesh","text":"ReAlignTriMesh(target::TriMesh; inplace::Bool=true)\n\nRe-Align TriMesh to axis aligned bounding box of mesh at index in TriMesh target.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: realign, realign!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.RotatePointCloud","page":"Home","title":"Flux3D.RotatePointCloud","text":"RotatePointCloud(rotmat::AbstractArray{<:Number,2}; inplace::Bool=true)\n\nRotate PointCloud with a given rotation matrix rotmat.\n\nrotmat must be AbstractArray{<:Number,2} of size (3,3). inplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of PointCloud. Given rotmat, this transform will rotate each point coordinates (ie. x,y,z) in PointCloud.\n\nSee also: rotate, rotate!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.RotateTriMesh","page":"Home","title":"Flux3D.RotateTriMesh","text":"RotateTriMesh(rotmat::AbstractArray{<:Number,2}; inplace::Bool=true)\n\nRotate vertices of TriMesh with a given rotation matrix rotmat.\n\nrotmat must be AbstractArray{<:Number,2} of size (3,3). inplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh. Given rotmat, this transform will rotate each vertices coordinates (ie. x,y,z) in TriMesh.\n\nSee also: rotate, rotate!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.ScalePointCloud","page":"Home","title":"Flux3D.ScalePointCloud","text":"ScalePointCloud(factor::Number; inplace::Bool=true)\n\nScale PointCloud with a given scaling factor factor.\n\nfactor should be strictly greater than 0.0 for obvious reason. inplace is optional keyword argument, to make transformation in-place. If inplace is set to false, it will create deepcopy of PointCloud. Given factor, this transform scale each point in PointCloud, ie. point = point * factor\n\nSee also: scale, scale!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.ScaleTriMesh","page":"Home","title":"Flux3D.ScaleTriMesh","text":"ScaleTriMesh(factor::Number; inplace::Bool=true)\n\nScale TriMesh with a given scaling factor factor.\n\nfactor should be strictly greater than 0.0 for obvious reason. inplace is optional keyword argument, to make transformation in-place. If inplace is set to false, it will create deepcopy of TriMesh. Given factor, this transform scale each vertices in TriMesh, ie. point = point * factor\n\nSee also: scale, scale!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.TranslateTriMesh","page":"Home","title":"Flux3D.TranslateTriMesh","text":"TranslateTriMesh(vector::AbstractArray{<:Number}; inplace::Bool=true)\n\nTranslate TriMesh with given translation vector.\n\ninplace is optional keyword argument, to make transformation in-place If inplace is set to false, it will create deepcopy of TriMesh.\n\nSee also: translate, translate!\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.TriMesh","page":"Home","title":"Flux3D.TriMesh","text":"TriMesh\n\nInitialize Triangle Mesh representation.\n\nFields:\n\nN                       - Batch size of TriMesh.\nV                       - Maximum vertices per mesh in TriMesh.\nF                       - Maximum faces per mesh in TriMesh.\nequalised               - Bool, indicates all mesh have same verts and faces size.\nvalid                   -\noffset                  - Offset indicating number to be added to migrate to 0-indexed system.\n_verts_len              - Number of vertices in each mesh of TriMesh.\n_verts_list             - Vertices in list format.\n_verts_packed           - Vertices in packed format.\n_verts_padded           - Vertices in padded format.\n_faces_len              - Number of faces in each mesh of TriMesh.\n_faces_list             - Vertices in list format.\n_faces_packed           - Vertices in packed format.\n_faces_padded           - Vertices in padded format.\n_edges_packed           - Edges in packed format (according to packed vertices).\n_faces_to_edges_packed  - Faces formed by edges in packed format (according to packed edges).\n_laplacian_packed       - Laplacian sparce matrix in packed format.\n_edges_to_key           - Dict mapping edges tuple to unique key.\n\nAvailable Contructor:\n\nTriMesh(verts_list, faces_list; offset::Number = -1)\nTriMesh(m::Vector{<:GeometryBasics.Mesh})\nTriMesh(m::GeometryBasics.Mesh)\nTriMesh(m::TriMesh)\n\n\n\n\n\n","category":"type"},{"location":"#Flux3D.GBMesh-Union{Tuple{R}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{R,2}}} where R where T","page":"Home","title":"Flux3D.GBMesh","text":"GBMesh(m::TriMesh; index::Int = 1)\nGBMesh(verts::AbstractArray{T,2}, faces::AbstractArray{R,2}) where {T,R}\n\nInitialize GeometryBasics.Mesh from triangle mesh in TriMesh m at index.\n\nSee also: gbmeshes\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_faces_areas_list-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_faces_areas_list","text":"compute_faces_areas_list(m::TriMesh)\n\nComputes area of faces of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_areas_padded, compute_faces_areas_packed\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_faces_areas_list(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_faces_areas_packed-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_faces_areas_packed","text":"compute_faces_areas_packed(m::TriMesh)\n\nComputes area of faces of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_areas_padded, compute_faces_areas_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_faces_areas_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_faces_areas_padded-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_faces_areas_padded","text":"compute_faces_areas_padded(m::TriMesh)\n\nComputes area of faces of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_areas_packed, compute_faces_areas_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_faces_areas_padded(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_faces_normals_list-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_faces_normals_list","text":"compute_faces_normals_list(m::TriMesh)\n\nComputes Unit normal of faces of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_normals_padded, compute_faces_normals_packed\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_faces_normals_list(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_faces_normals_packed-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_faces_normals_packed","text":"compute_faces_normals_packed(m::TriMesh)\n\nComputes Unit normal of faces of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_normals_padded, compute_faces_normals_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_faces_normals_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_faces_normals_padded-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_faces_normals_padded","text":"compute_faces_normals_padded(m::TriMesh)\n\nComputes Unit normal of faces of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: compute_faces_normals_packed, compute_faces_normals_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_faces_normals_padded(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_verts_normals_list-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_verts_normals_list","text":"compute_verts_normals_list(m::TriMesh)\n\nComputes Unit normal of vertices of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Normal vec of each vertex is weighted sum of normals of adjacent faces, weighted by corresponding faces areas and then normalize to unit vector.\n\nSee also: compute_verts_normals_padded, compute_verts_normals_packed\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_verts_normals_list(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_verts_normals_packed-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_verts_normals_packed","text":"compute_verts_normals_packed(m::TriMesh)\n\nComputes Unit normal of vertices of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Normal vec of each vertex is weighted sum of normals of adjacent faces, weighted by corresponding faces areas and then normalize to unit vector.\n\nSee also: compute_verts_normals_padded, compute_verts_normals_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_verts_normals_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.compute_verts_normals_padded-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.compute_verts_normals_padded","text":"compute_verts_normals_padded(m::TriMesh)\n\nComputes Unit normal of vertices of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Normal vec of each vertex is weighted sum of normals of adjacent faces, weighted by corresponding faces areas and then normalize to unit vector.\n\nSee also: compute_verts_normals_packed, compute_verts_normals_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> compute_verts_normals_padded(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.gbmeshes-Tuple{TriMesh}","page":"Home","title":"Flux3D.gbmeshes","text":"gbmeshes(m::TriMesh)\n\nInitialize list of GeometryBasics.Mesh from TriMesh m\n\nSee also: gbmeshes\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_edges_packed-Union{Tuple{TriMesh{T,R,S} where S}, Tuple{R}, Tuple{T}} where R where T","page":"Home","title":"Flux3D.get_edges_packed","text":"get_edges_packed(m::TriMesh; refresh::Bool = false)\n\nReturns edges of TriMesh m in packed format. Edges are according to the indices of corresponding vertices in get_verts_packed(m)\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_packed, get_faces_to_edges_packed\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_edges_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_edges_to_key-Union{Tuple{TriMesh{T,R,S} where S}, Tuple{R}, Tuple{T}} where R where T","page":"Home","title":"Flux3D.get_edges_to_key","text":"get_edges_to_key(m::TriMesh; refresh::Bool = false)\n\nReturns dict mapping edges (tuple) of TriMesh m to unique key. Edges are according to the indices of corresponding vertices inget_verts_packed(m)\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_packed\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_edges_to_key(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_faces_list-Union{Tuple{TriMesh{T,R,S} where S}, Tuple{R}, Tuple{T}} where R where T","page":"Home","title":"Flux3D.get_faces_list","text":"get_faces_list(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_faces_padded, get_faces_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_faces_list(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_faces_packed-Union{Tuple{TriMesh{T,R,S} where S}, Tuple{R}, Tuple{T}} where R where T","page":"Home","title":"Flux3D.get_faces_packed","text":"get_faces_packed(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_faces_padded, get_faces_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_faces_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_faces_padded-Union{Tuple{TriMesh{T,R,S} where S}, Tuple{R}, Tuple{T}} where R where T","page":"Home","title":"Flux3D.get_faces_padded","text":"get_faces_padded(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_faces_padded, get_faces_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_faces_padded(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_faces_to_edges_packed-Union{Tuple{TriMesh{T,R,S} where S}, Tuple{R}, Tuple{T}} where R where T","page":"Home","title":"Flux3D.get_faces_to_edges_packed","text":"get_faces_to_edges_packed(m::TriMesh; refresh::Bool = false)\n\nReturns faces of TriMesh m in form of edges. Each edge corresponds to the indices of get_edges_packed(m).\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m. Assuming face f consists of (v1,v2,v3) vertices, and e1 = {v2,v3}, e2 = {v3,v1}, e3 = {v1,v2}, so face f in form of edges would be (e1,e2,e3).\n\nSee also: get_edges_packed\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_faces_to_edges_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_laplacian_packed-Union{Tuple{TriMesh{T,R,S} where S}, Tuple{R}, Tuple{T}} where R where T","page":"Home","title":"Flux3D.get_laplacian_packed","text":"get_laplacian_packed(m::TriMesh; refresh::Bool = false)\nget_laplacian_sparse(m::TriMesh; refresh::Bool = false)\n\nReturns Laplacian sparce matrix of TriMesh m.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: laplacian_loss\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_laplacian_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_verts_list-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.get_verts_list","text":"get_verts_list(m::TriMesh; refresh::Bool = false)\n\nReturns vertices of TriMesh m in list format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_padded, get_verts_packed\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_verts_list(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_verts_packed-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.get_verts_packed","text":"get_verts_packed(m::TriMesh; refresh::Bool = false)\n\nReturns vertices of TriMesh m in packed format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_padded, get_verts_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_verts_packed(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.get_verts_padded-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}} where S where R where T","page":"Home","title":"Flux3D.get_verts_padded","text":"get_verts_padded(m::TriMesh; refresh::Bool = false)\n\nReturns vertices of TriMesh m in padded format.\n\nrefresh is an optional keyword argument to recompute this format for TriMesh m.\n\nSee also: get_verts_packed, get_verts_list\n\nExamples:\n\njulia julia> m = load_trimesh(\"teapot.obj\") julia> get_verts_padded(m)`\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.load_trimesh-Tuple{String}","page":"Home","title":"Flux3D.load_trimesh","text":"load_trimesh(fn::String)\nload_trimesh(fns::Vector{String})\n\nLoad TriMesh from file(s). It will load TriMesh with multiple meshes, if list of files fns is given.\n\nSupported formats are obj, stl, ply, off and 2DM.\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.npoints-Tuple{PointCloud}","page":"Home","title":"Flux3D.npoints","text":"npoints(p::PointCloud)\n\nReturns the size of PointCloud.\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.sample_points-Union{Tuple{TriMesh{T,R,S}}, Tuple{S}, Tuple{R}, Tuple{T}, Tuple{TriMesh{T,R,S},Int64}} where S where R where T","page":"Home","title":"Flux3D.sample_points","text":"sample_points(m::TriMesh, num_samples::Int=5000; returns_normals::Bool=false, eps::Number = 1e-6)\n\nUniformly samples num_samples points from the surface of TriMesh m.\n\nreturns_normals is optional keyword argument, to returns normals from respective faces of samples. eps is optional keyword argument for a small number to prevent division by zero for small surface areas.\n\nExamples:\n\njulia> m = loadtrimesh(\"teapot.obj\") julia> points = samplepoints(m, 5000) julia> points, normals = samplepoints(m, 5000; returnsnormals=true)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.save_trimesh","page":"Home","title":"Flux3D.save_trimesh","text":"save_trimesh(fn::String, mesh::TriMesh, index::Int = 1)\nsave_trimesh(fn::String, mesh::GeometryBasics.Mesh)\n\nSave mesh in given fn. index is an optional argument specifing the index of mesh, incase of multiple meshes in TriMesh mesh.\n\nSupported formats are obj, stl, ply, off and 2DM.\n\n\n\n\n\n","category":"function"},{"location":"#Flux3D._load_meta-Tuple{GeometryBasics.Mesh}","page":"Home","title":"Flux3D._load_meta","text":"_load_meta(m::GeometryBasics.Mesh)\n\nReturns vertices and faces in Array format.\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.normalize!-Tuple{PointCloud}","page":"Home","title":"Flux3D.normalize!","text":"normalize!(pcloud::PointCloud)\n\nNormalize the PointCloud pcloud with mean centered at origin and unit standard deviation and overwrite the pcloud with normalized PointCloud.\n\nSee also: normalize\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> normalize!(p)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.normalize!-Tuple{TriMesh}","page":"Home","title":"Flux3D.normalize!","text":"normalize!(m::TriMesh)\n\nNormalize each mesh in TriMesh m with mean centered at origin and unit standard deviation and overwrite the m with normalized TriMesh.\n\nSee also: normalize\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> normalize!(m)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.normalize-Tuple{PointCloud}","page":"Home","title":"Flux3D.normalize","text":"normalize(pcloud::PointCloud)\n\nNormalize the PointCloud pcloud with mean centered at origin and unit standard deviation\n\nSee also: normalize!\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> p = normalize(p)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.normalize-Tuple{TriMesh}","page":"Home","title":"Flux3D.normalize","text":"normalize(m::TriMesh)\n\nNormalize each mesh in TriMesh m with mean centered at origin and unit standard deviation\n\nSee also: normalize!\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> m = normalize(m)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.offset-Tuple{TriMesh,AbstractArray{#s88,2} where #s88<:Number}","page":"Home","title":"Flux3D.offset","text":"offset(m::TriMesh, offset_verts_packed::AbstractArray{<:Number,2})\n\nAdd offset to the vertices of the TriMesh m by offset vertices offset_verts_packed.\n\nSee also: offset!\n\nExamples:\n\n```julia julia> m = loadtrimesh(\"teapot.obj\") julia> offsetverts = ones(getvertspacked(m)) julia> m = offset(m, offset_verts)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.realign!-Tuple{PointCloud,AbstractArray{Float32,2},AbstractArray{Float32,2}}","page":"Home","title":"Flux3D.realign!","text":"realign!(src::PointCloud, tgt::PointCloud)\nrealign!(src::PointCloud, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the PointCloud src with the axis aligned bounding box of PointCloud tgt and overwrite pcloud with re-aligned PointCloud.\n\nPointCloud src and tgt should be of same dimension.\n\nSee also: realign\n\nExamples:\n\njulia> src = PointCloud(rand(1024,3))\njulia> tgt = PointCloud(rand(1024,3))\njulia> realign!(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.realign!-Tuple{TriMesh,AbstractArray{Float32,2},AbstractArray{Float32,2}}","page":"Home","title":"Flux3D.realign!","text":"realign!(src::TriMesh, tgt::TriMesh)\nrealign!(src::TriMesh, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the TriMesh src with the axis aligned bounding box of mesh at index in TriMesh tgt and overwrite src with re-aligned TriMesh.\n\nSee also: realign\n\nExamples:\n\njulia> src = load_trimesh(\"teapot.obj\")\njulia> tgt = scale(src, 2.0)\njulia> realign!(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.realign-Tuple{PointCloud,AbstractArray{#s87,2} where #s87<:Number,AbstractArray{#s86,2} where #s86<:Number}","page":"Home","title":"Flux3D.realign","text":"realign(src::PointCloud, tgt::PointCloud)\nrealign(src::PointCloud, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the PointCloud src with the axis aligned bounding box of PointCloud tgt.\n\nPointCloud src and tgt should be of same dimension.\n\nSee also: realign!\n\nExamples:\n\njulia> src = PointCloud(rand(1024,3))\njulia> tgt = PointCloud(rand(1024,3))\njulia> src = realign!(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.realign-Tuple{TriMesh,AbstractArray{#s87,2} where #s87<:Number,AbstractArray{#s86,2} where #s86<:Number}","page":"Home","title":"Flux3D.realign","text":"realign(src::TriMesh, tgt::TriMesh, index::Integer=1)\nrealign(src::TriMesh, tgt_min::AbstractArray{<:Number,2}, tgt_max::AbstractArray{<:Number,2})\n\nRe-Align the TriMesh src with the axis aligned bounding box of mesh at index in TriMesh tgt.\n\nSee also: realign\n\nExamples:\n\njulia> src = load_trimesh(\"teapot.obj\")\njulia> tgt = scale(src, 2.0)\njulia> src = realign(src, tgt)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.rotate!-Tuple{PointCloud,AbstractArray{Float32,2}}","page":"Home","title":"Flux3D.rotate!","text":"rotate!(pcloud::PointCloud, rotmat::AbstractArray{Number,2})\n\nRotate the PointCloud pcloud by rotation matrix rotmat and overwrite pcloud with rotated PointCloud.\n\nRotation matrix rotmat should be of size (3,3)\n\nSee also: rotate\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> rotmat = rand(3,3)\njulia> rotate!(p, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.rotate!-Tuple{TriMesh,AbstractArray{Float32,2}}","page":"Home","title":"Flux3D.rotate!","text":"rotate!(m::TriMesh, rotmat::AbstractArray{<:Number,2})\n\nRotate the TriMesh m by rotation matrix rotmat and overwrite m with rotated TriMesh.\n\nRotation matrix rotmat should be of size (3,3)\n\nSee also: rotate\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> rotmat = rand(3,3)\njulia> rotate!(m, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.rotate-Tuple{PointCloud,AbstractArray{Float32,2}}","page":"Home","title":"Flux3D.rotate","text":"rotate(pcloud::PointCloud, rotmat::Array{Number,2})\n\nRotate the PointCloud pcloud by rotation matrix rotmat.\n\nRotation matrix rotmat should be of size (3,3)\n\nSee also: rotate!\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> rotmat = rand(3,3)\njulia> p = rotate(p, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.rotate-Tuple{TriMesh,AbstractArray{#s88,2} where #s88<:Number}","page":"Home","title":"Flux3D.rotate","text":"rotate(m::TriMesh, rotmat::AbstractArray{<:Number,2})\n\nRotate the TriMesh m by rotation matrix rotmat.\n\nRotation matrix rotmat should be of size (3,3)\n\nSee also: rotate!\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> rotmat = rand(3,3)\njulia> m = rotate(m, rotmat)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.scale!-Tuple{PointCloud,Float32}","page":"Home","title":"Flux3D.scale!","text":"scale!(pcloud::PointCloud, factor::Number)\n\nScale the PointCloud pcloud by scaling factor factor and overwrite pcloud with scaled PointCloud.\n\nScaling factor factor should be strictly greater than 0.0.\n\nSee also: scale\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> scale!(p, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.scale!-Tuple{TriMesh,Float32}","page":"Home","title":"Flux3D.scale!","text":"scale!(m::TriMesh, factor::Number)\nscale!(m::TriMesh, factor::AbstractArray{<:Number})\n\nScale the TriMesh m by scaling factor factor and overwrite m with scaled TriMesh. If factor is array of size (3, ), then TriMesh will be scale by scaling factor of respective dimension.\n\nScaling factor factor (each element in case of array) should be strictly greater than 0.0.\n\nSee also: scale\n\nExamples:\n\njulia> m = load_trimesh(\"teapot.obj\")\njulia> scale!(m, 1.0)\njulia> scale!(m, [1.0, 1.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.scale-Tuple{PointCloud,Float32}","page":"Home","title":"Flux3D.scale","text":"scale(pcloud::PointCloud, factor::Number)\n\nScale the PointCloud pcloud by scaling factor factor.\n\nScaling factor factor should be strictly greater than 0.0.\n\nSee also: scale!\n\nExamples:\n\njulia> p = PointCloud(rand(1024,3))\njulia> p = scale(1.0)\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.scale-Tuple{TriMesh,Union{Float32, AbstractArray{Float32,N} where N}}","page":"Home","title":"Flux3D.scale","text":"scale(m::TriMesh, factor::Number)\nscale(m::TriMesh, factor::AbstractArray{<:Number})\n\nScale the TriMesh m by scaling factor factor. If factor is array of size (3, ), then TriMesh will be scaleby scaling factor of respective dimension.\n\nScaling factor factor (each element in case of array) should be strictly greater than 0.0.\n\nSee also: scale!\n\nExamples:\n\n```julia julia> m = load_trimesh(\"teapot.obj\") julia> m = scale(m, 1.0) julia> m = scale!(m, [1.0, 1.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.translate!-Tuple{TriMesh,Float32}","page":"Home","title":"Flux3D.translate!","text":"translate!(m::TriMesh, vector::Number)\ntranslate!(m::TriMesh, vector::AbstractArray{<:Number})\n\nTranslate the TriMesh m by translating vector vector and overwrite m with translated TriMesh. If vector is a number, then TriMesh will be translated by same number in all dimension.\n\nSee also: translate\n\nExamples:\n\n```julia julia> m = load_trimesh(\"teapot.obj\") julia> translate!(m, 0.0) julia> translate!(m, [0.0, 0.0, 0.0])\n\n\n\n\n\n","category":"method"},{"location":"#Flux3D.translate-Tuple{TriMesh,Vararg{Any,N} where N}","page":"Home","title":"Flux3D.translate","text":"translate(m::TriMesh, vector::Number)\ntranslate(m::TriMesh, vector::AbstractArray{<:Number})\n\nTranslate the TriMesh m by translating vector vector. If vector is a number, then TriMesh will be translated by same number in all dimension.\n\nSee also: translate!\n\nExamples:\n\n```julia julia> m = load_trimesh(\"teapot.obj\") julia> m = translate(m, 0.0) julia> m = translate(m, [0.0, 0.0, 0.0])\n\n\n\n\n\n","category":"method"}]
}
